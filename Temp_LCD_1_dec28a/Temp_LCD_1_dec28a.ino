/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/ca848f51-a8f0-4536-beaa-d5c4c70e13fd 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float humi;
  float tempC;
  float tempF;
  int hours;
  int minutes;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128  // OLED display width, in pixels
#define SCREEN_HEIGHT 64  // OLED display height, in pixels

// Declaration for SSD1306 display connected using I2C
#define OLED_RESET -1  // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#include <LiquidCrystal_I2C.h> 
#include "DHT.h"
#define DHT11_PIN 2  // Define the pin used to connect the sensor
#define DHTTYPE DHT11  // Define the type of the sensor
#define ledPin 3  // LED info on change
#define button1Pin 7  // Yellow button to change C / F
#define button2Pin 8  // Red button to set backlight ON / OFF
#define button3Pin 9  // Green button to change OLED info

LiquidCrystal_I2C lcd(0x27, 16, 2); // I2C address 0x27, 16 column and 2 rows
DHT dht11(DHT11_PIN, DHT11);  // Create a DHT object

float humi_old;
float tempC_old;
float tempF_old;

bool showTempC = true;
bool showTempC_old = true;
int showOLED = 1;

bool showBacklight = true;

// Include the RTC library
#include "RTC.h"

//Include the NTP library
#include <NTPClient.h>

#include <WiFiUdp.h>
///////please enter your sensitive data in the Secret tab/arduino_secrets.h
//char ssid[] = SECRET_SSID;        // your network SSID (name)
//char pass[] = SECRET_PASS;    // your network password (use for WPA, or use as key for WEP)

//int wifiStatus = WL_IDLE_STATUS;
WiFiUDP Udp; // A UDP instance to let us send and receive packets over UDP
NTPClient timeClient(Udp);

#include "Arduino_LED_Matrix.h"

ArduinoLEDMatrix matrix;

byte Time[8][12] {
  {0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0}
};

byte Clear[8][12] {
  {1,0,1,0,0,0,0,0,0,1,0,1},
  {0,1,0,0,0,1,1,0,0,0,1,0},
  {0,0,0,0,1,1,1,1,0,0,0,0},
  {1,1,0,1,1,1,1,1,1,0,1,1},
  {1,1,0,0,1,1,1,1,0,0,1,1},
  {0,0,1,0,0,1,1,0,0,1,0,0},
  {0,1,0,1,0,0,0,0,1,0,1,0},
  {1,0,1,0,0,1,1,0,0,1,0,1}
};

byte Clouds[8][12] {
  {0,0,1,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,0,0,0,0,0,0,0,0},
  {1,1,1,1,1,0,0,0,0,0,0,0},
  {0,1,1,1,0,0,0,0,0,1,0,0},
  {0,0,1,0,0,0,0,0,1,1,1,0},
  {0,0,0,0,0,0,0,1,1,1,1,1},
  {0,0,0,0,0,0,0,0,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,1,0,0}
};

byte Rain[8][12] {
  {1,0,1,0,1,0,1,0,1,0,1,0},
  {0,1,0,1,0,1,0,1,0,1,0,1},
  {1,0,1,0,1,0,1,0,1,0,1,0},
  {0,1,0,1,0,1,0,1,0,1,0,1},
  {1,0,1,0,1,0,1,0,1,0,1,0},
  {0,1,0,1,0,1,0,1,0,1,0,1},
  {1,0,1,0,1,0,1,0,1,0,1,0},
  {0,1,0,1,0,1,0,1,0,1,0,1}
};

byte Snow[8][12] {
  {0,0,1,0,0,1,0,0,1,0,0,0},
  {0,0,0,1,0,1,0,1,0,0,0,0},
  {0,0,0,0,1,1,1,0,0,0,0,0},
  {1,1,1,1,1,1,1,1,1,1,1,1},
  {0,0,0,0,1,1,1,0,0,0,0,0},
  {0,0,0,1,0,1,0,1,0,0,0,0},
  {0,0,1,0,0,1,0,0,1,0,0,0},
  {0,1,0,0,0,1,0,0,0,1,0,0}
};

byte Digits[5][30] {
  {1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {1,0,1,0,0,1,0,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,1},
  {1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1},
  {1,0,1,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,0,1,1,0,1,0,0,1},
  {1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1}
};

byte secondsON_OFF = 1;
int currentSecond;

void displayDigit(int d, int s_x, int s_y) {
  for (int i=0; i<3; i++)
    for (int j=0; j<5; j++)
      Time[i+s_x][11-j-s_y] = Digits[j][i+d*3];
}

unsigned long previousMillis_SET = millis();
const long interval_SET = 50000;
bool wifiState = true;

const char* wl_status_to_string(int status) {
  switch (status) {
    case 0: return "WL_IDLE_STATUS";
    case 1: return "WL_NO_SSID_AVAIL";
    case 2: return "WL_SCAN_COMPLETED";
    case 3: return "WL_CONNECTED";
    case 4: return "WL_CONNECT_FAILED";
    case 5: return "WL_CONNECTION_LOST";
    case 6: return "WL_DISCONNECTED";
  }
}

const int timeZoneOffsetHours = 2;


//#include "WiFiS3.h"

///////please enter your sensitive data in the Secret tab/arduino_secrets.h
char ssid[] = SECRET_SSID;        // your network SSID (name)
char pass[] = SECRET_OPTIONAL_PASS;    // your network password (use for WPA, or use as key for WEP)
int keyIndex = 0;            // your network key index number (needed only for WEP)

int status = WL_IDLE_STATUS;

// Initialize the WiFi client library
WiFiClient client;

// server address:
//char server[] = "example.org";
char server[] = "www.funkacer.cz";
//IPAddress server(64,131,82,241);

unsigned long lastConnectionTime1 = 0;            // last time you connected to the server, in milliseconds
unsigned long lastConnectionTime2 = 0;            // last time you connected to the server, in milliseconds
const unsigned long postingInterval1 = 10L * 1000L; // delay between updates, in milliseconds
const unsigned long postingInterval2 = 55L * 1000L; // delay between updates, in milliseconds
String last1 = "";
String last2 = "";
String previousLast = "";

String temp_min = "";
String temp_max = "";
String w_main = "";

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  dht11.begin();     // initialize the sensor

  lcd.init();        // initialize the lcd
  lcd.clear();       // clear the LCD display
  lcd.backlight();   // Make sure backlight is on
  pinMode(ledPin, OUTPUT);
  pinMode(button1Pin, INPUT_PULLUP);
  pinMode(button2Pin, INPUT_PULLUP);
  pinMode(button3Pin, INPUT_PULLUP);
  //define LED as output
  pinMode(LED_BUILTIN, OUTPUT);

  matrix.begin();

  //matrix.loadFrame(LEDMATRIX_MUSIC_NOTE);

  timeClient.begin();
  
  RTC.begin();

  // initialize the OLED object
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ;
  }

}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  
  // wait a few seconds between measurements.
  delay(100);

  // read humidity
  humi = dht11.readHumidity();
  // read temperature as Celsius
  tempC = dht11.readTemperature();
  // read temperature as Fahrenheit
  tempF = dht11.readTemperature(true);

  int sensor1Val = digitalRead(button1Pin);
  int sensor2Val = digitalRead(button2Pin);
  int sensor3Val = digitalRead(button3Pin);

  if (sensor1Val == LOW) {
    showTempC = !showTempC;
    delay(100);
  }
  if (sensor2Val == LOW) {
    showBacklight = !showBacklight;
    if (showBacklight) {
      lcd.backlight();
    } else {
      lcd.noBacklight();
    }
    delay(100);
  }
  if (sensor3Val == LOW) {
    showOLED < 4 ? showOLED += 1 : showOLED = 0;
    Serial.println(showOLED);
    delay(100);
  }

  digitalWrite(ledPin, LOW);

  if (showTempC) {
    // check if any reads failed
    if (isnan(humi) || isnan(tempC)) {
      lcd.clear();
      lcd.setCursor(0, 0);   //put "Failed" in LCD1602 (0,0)
      lcd.print("Failed");
    } else if (humi != humi_old || tempC != tempC_old || showTempC != showTempC_old) {
      lcd.clear();
      lcd.setCursor(0, 0);  // start to print at the first row
      //lcd.print("Temp: ");
      lcd.print("Teplota: ");
      lcd.print(tempC);     // print the temperature
      lcd.print((char)223); // print ° character
      lcd.print("C");
      lcd.setCursor(0, 1);  // start to print at the second row
      //lcd.print("Humi: ");
      lcd.print("Vlhkost: ");
      lcd.print(humi);      // print the humidity
      lcd.print("%");
      digitalWrite(ledPin, HIGH);
      //writeOLED(hours, minutes, tempC, humi, 0);
    }
  } else {
    // check if any reads failed
    if (isnan(humi) || isnan(tempF)) {
      lcd.clear();
      lcd.setCursor(0, 0);   //put "Failed" in LCD1602 (0,0)
      lcd.print("Failed");
    } else if (humi != humi_old || tempF != tempF_old || showTempC != showTempC_old) {
      lcd.clear();
      lcd.setCursor(0, 0);  // start to print at the first row
      //lcd.print("Temp: ");
      lcd.print("Teplota: ");
      lcd.print(tempF);     // print the temperature
      lcd.print((char)223); // print ° character
      lcd.print("F");
      lcd.setCursor(0, 1);  // start to print at the second row
      //lcd.print("Humi: ");
      lcd.print("Vlhkost: ");
      lcd.print(humi);      // print the humidity
      lcd.print("%");
      digitalWrite(ledPin, HIGH);
      //writeOLED(hours, minutes, tempF, humi, 0);
    }
  }

  humi_old = humi;
  tempC_old = tempC;
  tempF_old = tempF;

  showTempC_old = showTempC;

  RTCTime currentTime;
  unsigned long currentMillis = millis();
  
  if (currentMillis - previousMillis_SET >= interval_SET) {
    Serial.print("Millis difference time update: ");
    Serial.println(currentMillis - previousMillis_SET);
    //chci neidealne pocitat 50 s od posledniho updatu
    previousMillis_SET = currentMillis;
    // Get the current date and time from an NTP server and convert
    // it to UTC +2 by passing the time zone offset in hours.
    // You may change the time zone offset to your local one.
    Serial.print("WifiState = ");
    Serial.println(wifiState);
    Serial.println(wl_status_to_string(WiFi.status()));
    if (WiFi.status() != WL_CONNECTED) {
      wifiState = false;
    }
    if (wifiState) {
      int i = timeClient.update();
      if (i) {
        auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600);
        Serial.print("Unix time = ");
        Serial.println(unixTime);
        RTCTime timeToSet = RTCTime(unixTime);
        RTC.setTime(timeToSet);
        // Retrieve the date and time from the RTC and print them
        RTC.getTime(currentTime); 
        Serial.println("The RTC was just set to: " + String(currentTime));
        digitalWrite(LED_BUILTIN, HIGH);
      } else {
        digitalWrite(LED_BUILTIN, LOW);
      }
    } else {
      digitalWrite(LED_BUILTIN, LOW);
    }
  }

  RTC.getTime(currentTime);

  if (currentTime.getSeconds() != currentSecond) {
    secondsON_OFF ? secondsON_OFF = 0 : secondsON_OFF = 1;
    //displayDigit(1,0,0);
    //displayDigit(2,4,0);
    //displayDigit(4,1,6);
    //displayDigit(5,5,6);
    //displayDigit((int) currentTime.getHour() / 10, 0, 0);
    //displayDigit(currentTime.getHour() % 10, 4, 0);
    //displayDigit((int) currentTime.getMinutes() / 10, 1, 6);
    //displayDigit(currentTime.getMinutes() % 10, 5, 6);
    //Time[0][2] = secondsON_OFF;
    //Time[0][4] = secondsON_OFF;
    //matrix.renderBitmap(Time, 8, 12);
    currentSecond = currentTime.getSeconds();
    hours = currentTime.getHour();
    minutes = currentTime.getMinutes();
    //chci idealne pocitat 50 s od zacatku minuty
    if (!currentSecond) {
      previousMillis_SET = currentMillis;
    }
    
  }

  writeOLED(showOLED);

  // if there's incoming data from the net connection.
  // send it out the serial port.  This is for debugging
  // purposes only:
  
  String last = read_request();
  if (last != "") {

    //[{"temp_min":"2.7","temp_max":"14.4","w_main":"Clear"}]
    Serial.println(last);
    if (last != previousLast && last.substring(3, 11) == "temp_min") {
      //parse last
      
      Serial.println("Změna!");

      // Find first occurrence of the delimiter
      int pos1 = last.indexOf(',');
      
      // temp_min
      Serial.println(last.substring(14, pos1-1));
      temp_min = last.substring(14, pos1-1);

      int pos2 = last.indexOf(',', pos1+1);

      Serial.println(last.substring(pos1+13, pos2-1));

      temp_max = last.substring(pos1+13, pos2-1);

      Serial.println(last.substring(pos2+11, last.length()-3));

      w_main = last.substring(pos2+11, last.length()-3);

      if (w_main == "Clear") {
        matrix.renderBitmap(Clear, 8, 12);
      } else if (w_main == "Rain") {
        matrix.renderBitmap(Rain, 8, 12);
      } else if (w_main == "Snow") {
        matrix.renderBitmap(Snow, 8, 12);
      } else if (w_main == "Clouds") {
        matrix.renderBitmap(Clouds, 8, 12);
      } else {
        matrix.renderBitmap(Time, 8, 12);
      }

      previousLast = last;

    }
  }
  
  // if ten seconds have passed since your last connection,
  // then connect again and send data:
  if (millis() - lastConnectionTime1 > postingInterval1) {
    httpRequest1();
  }

  // if ten seconds have passed since your last connection,
  // then connect again and send data:
  if (millis() - lastConnectionTime2 > postingInterval2) {
    httpRequest2();
  }
  
}


void writeOLED (int showOLED) {
  if (showOLED == 1) {
      if (showTempC) {
      writeOLED1(hours, minutes, tempC, humi, secondsON_OFF);
    } else {
      writeOLED1(hours, minutes, tempF, humi, secondsON_OFF);
    }
  } else if (showOLED == 2) {
    writeOLED2(hours, minutes);
  } else if (showOLED == 3) {
    if (showTempC) {
      writeOLED3(hours, minutes, tempC, humi, secondsON_OFF);
    } else {
      writeOLED3(hours, minutes, tempF, humi, secondsON_OFF);
    }
  } else if (showOLED == 4) {
    if (showTempC) {
      writeOLED4(hours, minutes, tempC, humi);
    } else {
      writeOLED4(hours, minutes, tempF, humi);
    }
    //writeOLED3(hours, minutes);
  } else {
    display.clearDisplay();
    display.display();
  }
}

void writeOLED1(int hour, int minute, float teplota, float vlhkost, int sec) {
  // Clear the buffer.
  display.clearDisplay();

  display.setTextColor(WHITE);
  display.setTextSize(2);
  display.setCursor(0, 4);
  display.print("Time");
  //display.print(weather_i);
  display.setTextSize(4);
  display.setCursor(0, 36);
  //display.print("H:");
  if (hour < 10) {
    display.print("0" + (String)hour);
  } else {
    display.print(hour);
  }
  display.setCursor(45, 36);
  if (sec) display.print(":");
  display.setCursor(65, 36);
  if (minute < 10) {
    display.print("0" + (String)minute);
  } else {
    display.print(minute);
  }
  display.drawLine(50, 0, 50, 25, WHITE);
  display.drawLine(0, 25, 128, 25, WHITE);
  display.setTextSize(1);
  display.setCursor(55, 0);
  display.print("Teplota:");
  display.print(teplota, 1);
  display.setCursor(55, 15);
  display.print("Vlhkost:");
  display.print(vlhkost, 1);
  display.display();
}

void writeOLED2(int hour, int minute) {
  // Clear the buffer.
  display.clearDisplay();

  display.setTextColor(WHITE);
  
  display.setTextSize(2);
  display.setCursor(0, 2);
  display.print("Tmin:" + temp_min);
  display.setCursor(0, 24);
  display.print("Tmax:" + temp_max);
  display.setCursor(0, 46);
  display.print("Fore:" + w_main);
  display.display();
}

void writeOLED3(int hour, int minute, float teplota, float vlhkost, int sec) {
  // Clear the buffer.
  display.clearDisplay();

  display.setTextColor(WHITE);
  
  display.setTextSize(2);
  display.setCursor(0, 2);
  display.print("Temp:" + (String)teplota);
  display.setCursor(0, 24);
  display.print("Humi:" + (String)vlhkost);
  display.setCursor(0, 46);
  display.print("Time:");
  if (hour < 10) {
    display.print("0" + (String)hour);
  } else {
    display.print(hour);
  }
  if (sec) {
    display.print(":");
  } else {
    display.print(" ");
  }
  if (minute < 10) {
    display.print("0" + (String)minute);
  } else {
    display.print(minute);
  }
  display.display();
}

void writeOLED4(int hour, int minute, float teplota, float vlhkost) {
  // Clear the buffer.
  display.clearDisplay();

  display.setTextColor(WHITE);

  int hour1 = map(hour % 12, 0, 12, 0, 384-10*8);
  int minute1 = map(minute, 0, 60, 0, 384-5*8);
  int currentSecond1 = map(currentSecond, 0, 60, 0, 384);
  //int currentSecond2 = map(currentSecond, 0, 60, 0, 384-10*8);

  int x = 0;
  int y = 0;
  //int x1 = 0;
  //int y1 = 0;
  int q[] = {1,2,3,4};
  int qx[] = {77,77,13,13};
  int qy[] = {13,36,36,13};

  int h[] = {0,1,2,3,4,5,6,7,8,9,10,11};

  for (int i=0; i < 12; i++) {
    int h1 = map(h[i] % 12, 0, 12, 0, 384-10*8);
    getXY(h1, 10, &x, &y, &q[0], &q[1], &q[2], &q[3]);
    display.drawPixel(x, y, WHITE);
  }

  int m[] = {0,5,10,15,20,25,30,35,40,45,50,55};

  for (int i=0; i < 12; i++) {
    int m1 = map(m[i], 0, 60, 0, 384-5*8);
    getXY(m1, 5, &x, &y, &q[0], &q[1], &q[2], &q[3]);
    display.drawPixel(x, y, WHITE);
  }

  getXY(currentSecond1, 0, &x, &y, &q[0], &q[1], &q[2], &q[3]);
  //getXY(currentSecond2, 10, &x1, &y1);
  display.drawLine(64, 32, x, y, WHITE);
  //display.drawPixel(x, y, SSD1306_WHITE);
  //display.drawLine(x1, y1, x, y, WHITE);

  q[0] = 1;
  q[1] = 2;
  q[2] = 3;
  q[3] = 4;
  
  getXY(hour1, 10, &x, &y, &q[0], &q[1], &q[2], &q[3]);
  display.drawLine(64, 32, x, y, WHITE);
  
  getXY(minute1, 5, &x, &y, &q[0], &q[1], &q[2], &q[3]);
  display.drawLine(64, 32, x, y, WHITE);

  //zapni pro kontrolu kvadrantu
  /*
  Serial.print("q0");
  Serial.println(q[0]);
  Serial.print("q1");
  Serial.println(q[1]);
  Serial.print("q2");
  Serial.println(q[2]);
  Serial.print("q3");
  Serial.println(q[3]);
  */

  //preferuj protilehle
  if (q[0] == 1 && q[1] == 2 && q[3] == 4) {
    q[0] = 0;
  } else if (q[0] == 1 && q[1] == 2 && q[2] == 3) {
    q[1] = 0;
  } else if (q[1] == 2 && q[2] == 3 && q[3] == 4) {
    q[2] = 0;
  }

  for (int i=0; i<4; i++) {
    if (q[i] > 0) {
      display.setTextSize(2);
      display.setCursor(qx[i], qy[i]);
      display.print(teplota, 1);
      q[i] = 0;
      break;
    }
  }

  for (int i=0; i<4; i++) {
    if (q[i] > 0) {
      display.setTextSize(2);
      display.setCursor(qx[i], qy[i]);
      display.print(vlhkost, 1);
      q[i] = 0;
      break;
    }
  }
  
  display.display();
}

void getXY(int value, int offset, int* x, int* y, int* q0, int* q1, int* q2, int* q3) {
  *x = 0;
  *y = 0;
  //nastav x, y
  if (value >= 0 && value < 64 - offset) {
    *x = 64 + value;
    *y = offset;
  } else if (value >= 64 - offset && value < 128 - offset*3) {
    *x = 128-offset;
    *y = value - (64 - offset*2);
  } else if (value >= 128 - offset*3 && value < 256 - offset*5) {
    *x = 256 - offset*4 - value;
    *y = 64 - offset;
  } else if (value >= 256 - offset*5 && value < 320 - offset*7) {
    *x = offset;
    *y = 320 - offset*6 - value;
  } else if (value >= 320 - offset*7 && value < 384 - offset*8) {
    *x = value - (320 - offset*8);
    *y = offset;
  }
  //omez q (kvadranty) pro zobrazení temp a humi
  if (value >= 0 && value + offset*2 < 96) {
    *q0 = 0;
  } else if (value + offset*2 >= 96 && value + offset*4 < 192) {
    *q1 = 0;
  } else if (value + offset*4 >= 192 && value + offset*6 < 288) {
    *q2 = 0;
  } else if (value + offset*6 >= 288 && value + offset*8 < 384) {
    *q3 = 0;
  }
  return;  // no return value
}


/* just wrap the received data up to 80 columns in the serial print*/
/* -------------------------------------------------------------------------- */
String read_request() {
/* -------------------------------------------------------------------------- */  
  uint32_t received_data_num = 0;
  String last = "";
  int read = 0;

  while (client.available()) {
    /* actual data reception */
    char c = client.read();
    /* print data to serial port */
    //Serial.print(c);
    if (c == '[') {
      read = 1;
    }
    if (read == 1) {
      last += c;
    }
    /* wrap data to 80 columns*/
    received_data_num++;
    if(received_data_num % 160 == 0) { 
      //Serial.println();
    }
  }

  return last;
  
}


// this method makes a HTTP connection to the server:
/* -------------------------------------------------------------------------- */
void httpRequest1() {
/* -------------------------------------------------------------------------- */  
  // close any connection before send a new request.
  // This will free the socket on the NINA module
  client.stop();

  // if there's a successful connection:
  if (client.connect(server, 80)) {
  //if (client.connect(server, 443)) {
    Serial.println("connecting1...");
    // send the HTTP GET request:
    //client.println("GET /status/status HTTP/1.1");
    client.println("GET /weather/getday HTTP/1.1");
    client.println("Host: funkacer.cz");
    client.println("User-Agent: ArduinoWiFi/1.1");
    client.println("Connection: close");
    client.println();
    // note the time that the connection was made:
    lastConnectionTime1 = millis();
  } else {
    // if you couldn't make a connection:
    Serial.println("connection failed");
  }
}


// this method makes a HTTP connection to the server:
/* -------------------------------------------------------------------------- */
void httpRequest2() {
/* -------------------------------------------------------------------------- */  
  // close any connection before send a new request.
  // This will free the socket on the NINA module
  client.stop();

  // if there's a successful connection:
  if (client.connect(server, 80)) {
  //if (client.connect(server, 443)) {
    Serial.println("connecting2...");
    // send the HTTP GET request:
    //client.println("GET /status/status HTTP/1.1");
    client.println("GET /weather/getweather HTTP/1.1");
    client.println("Host: funkacer.cz");
    client.println("User-Agent: ArduinoWiFi/1.1");
    client.println("Connection: close");
    client.println();
    // note the time that the connection was made:
    lastConnectionTime2 = millis();
  } else {
    // if you couldn't make a connection:
    Serial.println("connection failed");
  }
}

/* -------------------------------------------------------------------------- */
void printWifiStatus() {
/* -------------------------------------------------------------------------- */  
  // print the SSID of the network you're attached to:
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());

  // print your board's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print("signal strength (RSSI):");
  Serial.print(rssi);
  Serial.println(" dBm");
}
